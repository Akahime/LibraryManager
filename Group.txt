Project Report
Is1220_Group 24 Thomas Cocher & Sarah Gross

Introduction


1)	Presentation of the project
This project is about developing a Library Management System (LMS). We have to implement with OOP a fully-operational library, where 3 kinds of items are stored books, CDs and DVDs. One can register to the library and then be able to consult onsite or borrow those items, with rules which depend on the status of their membership.
The first part of this project, which you are currently consulting, only deals with the design and the implementation of the classes which will be needed for this library “the library core”; the methods which enable the user to use the library will come in the second part.

2)	Analysis and design
The user of the LMS ought to be able to use it without understanding how it works. Therefore, we decided to implement a Factory pattern for the manipulation of library items.
We were not sure if using a Factory was the right solution because the information to give at the creation depends on the item, for instance a book needs an ISVN number. Which means that the user has to know beforehand which information are needed for each item, which is in contradiction with the idea that the user does not know the details of the factory… Thats is why we decided to create a dialogue box this the user where he would declare to type of item he desires, then the box asks him to fill in all the attributes needed one by one. If he entrers blanks for cumpulsory information or enters the wrong type of data (for instance a String where he is asked to enter a number) he is asked to fill again as long as he enters the wrong data. The second situation (wrong type) is managed by Exceptions of type InputMismatchException. While the user fills in these attributes, they are stored in a String ArrayList. Once he has filled all the attributes, an Object of the Class of the item requested is created from the information stored in the ArrayList.

We also wondered about how to manage the update of the status of the loans and the fidelity cards. Since we needed to continuously make updates, we decided to use an observer pattern for the reservation and the WARNING systems. Updating the cards every time the program was launched seemed a better solution. Thus, we created a Launcher class which implements all the actions we need when the Library is “opened” a new time
-	Creating a new Factory so that the user can create new items whenever he wants
-	Fetching from the database all the information about the Library
-	Updating all the expiration dates; for the fidelity cards or the loans.
We first made three functions for each kind of update, but since for each update we needed to make a loop on the list of the members, for speed considerations we decided to put all those updates in one same method, hence reducing the loops needed to one.
We realized that we needed a kind of database in order to keep all the information about our Library. In TPs, the examples were just to see if our code worked, we did not need our examples to remain once we had closed the program. However here it is different we have one single Library on which the users will work during several months so it is compulsory for the information to be accessible all this time and we have to be able to close the program without losing it!
The information needs therefore to be stored somewhere. Since we cannot have a kind of MySQL-like database with Java, we decided to use the InputOutput streams to store the composition of the Library and its members in text files. We decided to store the information about each member, and the information about the Library. The problem was then how to translate the idea of an object into a text file. That's where we decided to use serialization, which is exactly the function made for this. First we thought about serializing the Library and the Members, but after coding the serialization of the Library we realised that since the information about the members were all stored in the library.listMembers it was not necessary to serialize the Members alone.

In order to see clearly what to do, we first drew on paper the UML diagram of the LMS we stated which classes we needed, what attributes that had, of what type. We chose to use some type which were not seen in class, for instance the ENUM type for the attributes which had only a couple of values possible (items bookCDDVD , fidelity card standard, frequent, gold) because this type was created for this kind of use.
Thinking about the classes we needed made us reflecting about how they would be used in the project and thus raised the questions above.
Then we could start to implement the project.

3)	Implementation
a)	Code structure
b)	Testing
We hesitated about first making the tests we needed, then programming the classes which would make those tests work, as in the xxxxxx implementation seen in classes. The advantage is that we can see how much work is left very easily that way. Nevertheless since the methods were supposed to be programmed on the second part we could not use this strategy.

4)	Results


Conclusion
